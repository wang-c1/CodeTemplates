1、确定搜索区间初始化时候的左右边界，有时需要关注一下边界值。
   在初始化时，有时把搜索区间设置大一点没有关系，但是如果恰好把边界值排除在外，再怎么搜索都得不到结果。

2、无条件写上 while (left < right) ，表示退出循环的条件是 left == right，对于返回左右边界就不用思考了，因此此时它们的值相等；

3、先写下取整的中间数取法，然后从如何把 mid 排除掉的角度思考 if 和 else 语句应该怎样写。
      一般而言，要把“什么时候不是目标元素”作为注释写在代码中，提醒自己要判断正确，这一步判断非常关键，直接影响到后面的代码逻辑。
  然后接着思考 mid 不是解的情况下，mid 的左右两边可能存在解，把下一轮搜索的区间范围作为注释写进代码里，进而在确定下一轮搜索区间边界的收缩行为时，
  不容易出错。
  if 有把握写对的情况下，else 就是 if 的反面，可以不用思考，直接写出来。

  说明：这种思考方式，就正正好把待搜索区间从逻辑上分成两个区间，一个区间不可能存在目标元素，进而在另一个区间里继续搜索，更符合“二分”的语义。

4、根据 if else 里面写的情况，看看是否需要修改中间数下取整的行为。
   当区间只剩下两个数的时候，可能会出现死循环。比如left = 1，right = 2,mid = left + (right - left) / 2,这时候mid为1，
   永远取不到区间右边的值，就可能会出现死循环。这时候要向上取整，即mid = left + (right - left + 1) / 2
  （1）边界收缩行为 1： mid 被分到左边。即区间被分成 [left, mid] 与 [mid + 1, right]，此时取中间数的时候下取整。
    int mid = left + (right - left) / 2;
    if (check(mid)) {
        // 下一轮搜索区间是 [mid + 1, right]
        left = mid + 1;
    } else {
        right = mid;
    }
    
  （2）边界收缩行为 2： mid 被分到右边。即区间被分成 [left, mid - 1] 与 [mid, right]，此时取中间数的时候上取整。
    int mid = left + (right - left + 1) / 2;
    if (check(mid)) {
        // 下一轮搜索区间是 [left, mid - 1]
        right = mid - 1;
    } else {
        left = mid;
    }
    
    记住：在 if else 语句里面只要出现 left = mid 的时候，把去中间数行为改成上取整即可。
5、退出循环的时候，一定有 left == right 成立。有些时候可以直接返回 left （或者 right，由于它们相等，后面都省略括弧）或者与 left 相关的数值，
   有些时候还须要再做一次判断，判断 left 与 right 是否是我们需要查找的元素，这一步叫“后处理”。
